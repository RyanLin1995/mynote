# Linux 账号与群组
一般登录 Linux 的时候，输入的是字符串的账号，但是其实 Linux 主机并不会直接认识字符串组成的账号，它仅认识 ID 。由于计算机仅认识 0 与 1，所以主机对于数字比较有概念的；至于账号只是为了让人们容易记忆而已。而 ID 与账号的对应就在 `/etc/passwd` 文件中。

每个登入 Linux 的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称UID)、一个是群组 ID (Group ID ，简称 GID)。文件通过 UID 与 GID 判别它的拥有者与群组，当需要显示文件属性的需求时，系统会依据 `/etc/passwd` 与 `/etc/group` 的内容， 找到 UID / GID 对应的账号与组名再显示出来。

## 使用者账号
Linux 系统上面的用户如果需要登入主机以取得 shell 的环境来工作时，要先利用 tty1~tty6 的终端机提供的 login 接口，输入账号与密码登入 (网络登录使用 ssh) 。那么你输入账号密码后，系统会进行一下操作:
1. 匹配 `/etc/passwd` 里面是否存在输入的账号。没有则跳出，有则将该账号对应的 UID 与 GID (在 `/etc/group` 中) 读出来，且读出该账号的家目录与 shell 设定；
2. 再来则是在 `/etc/shadow` 里面找出对应的账号与 UID，然后核对一下输入的密码与保存的密码是否一致；
3. 如果一切都 OK ，就进入 Shell 

### /etc/passwd 文件结构
`/etc/passwd`中的文件结构是每一行都代表一个账号，有几行就代表有几个账号在系统中。
文件以 : 号作为分隔，每一个 : 是一个字段。

![passwd.png](https://i.loli.net/2021/05/05/sdBtir6CHN41XAO.png)

#### 字段详细说明：
* **1.账号名称**：即账号，用来登入系统且需要对应 UID 
* **2.密码**：代表该账号设置了密码，密码保存在` /etc/shadow 中``
* **3.UID**：使用者标识符，通常 Linux 对于 UID 有以下限制

|id 范围|该 ID 使用者特性|
|-|-|
|0 (系统管理员)|当 UID 是 0 时，代表这个账号是系统管理员，如果要让其他的账号也具有 root 的权限时，将该账号的 UID 改为 0 即可(但不建议)。也就是说，一个系统上不是叫 root 的就是系统管理员，而是 UID 为 0 的才是|
|1~999(系统账号)|保留给系统使用的 ID，除了 0 之外，其他的 UID 权限与特性并没有差别。由于系统上面启动的网络服务或背景服务希望使用较小的权限去运作，不希望直接使用 root 的身份去执行这些服务，所以默认 1000 以下的数字让给系统作为保留账号。这些系统账号通常是不可登入的。根据系统账号的由来，通常这类账号又约略被区分为两种：1~200：由 distributions 自行建立的系统账号；201~999：若用户有系统账号需求时，可以使用的账号 UID。|
|1000~60000(可登入账号)|给一般使用者建立账号使用|
* **4.GID**：关联 `/etc/group` 。通常新建账号时，也会在 `/etc/group` 中新建一个与账号名一样的 Group，两者就是靠 GID 关联起来
* **5.用户信息栏**：这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义
* **6.家目录**：用户的家目录，默认为 `/home/yourIDname`， root 的家目录在 /root 。如果某个账号的使用空间特别的大，可修改这个字段将用户登入家目录修改到别的地方。
* **7.Shell**：指定用户登入系统后取得 Shell 的类型。如果要禁止账号取得 shell 环境，就是 /sbin/nologin

### /etc/shadow 文件结构
`/etc/shadow` 文件结构跟 `/etc/passwd` 文件结构类似。每一行对应一个账号


* 问：为什么要有 `/etc/shadow` 文件？
* 答：早期的密码放在 `/etc/passwd` 的第二个字段上，密码也有加密过。程序运行需要到
 `/etc/passwd` 读取账号的权限。因此 `/etc/passwd` 的权限需设定为 `-rw-r--r--`。
但是加密过的密码够透过暴力破解法破解出来。因为这样，后来发展出将密码移动到 /etc/shadow 这个文件分隔开来的技术， 而且只有 root 有权限访问 `/etc/shadow` 。

`/etc/shadow` 同样以 : 为分隔符，一个 : 是一个字段

![shadow.png](https://i.loli.net/2021/05/15/TtOZ4NyqVhReXwA.png)

#### 字段详细说明：
* **1. 账号名称：** 文件的第一栏就是账号，必须要与 /etc/passwd 相同
* **2. 密码：** 账号真正的密码，经过编码(加密) 。不同的编码系统会造成这个字段的长度不相同。因为编码系统产生的密码长度必须一致，如果这个字段的长度改变后，该密码就会失效(算不出来)。很多软件透过这个功能，在此字段前加上 ! 或 * 改变密码字段长度，就会让密码『暂时失效』了。
3. 最近更动密码的日期：
这个字段记录了『更动密码那一天』的日期，不过，很奇怪呀！在我的例子中怎么会是 16559 呢？呵呵，
这个是因为计算 Linux 日期的时间是以 1970 年 1 月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则
为 366 啦！ 得注意一下这个资料呦！上述的 16559 指的就是 2015-05-04 那一天啦！了解乎？ 而想要了
解该日期可以使用本章后面 chage 指令的帮忙！至于想要知道某个日期的累积日数， 可使用如下的程序计
算：
[root@study ~]# echo $(($(date --date="2015/05/04" +%s)/86400+1))
16559
上述指令中，2015/05/04 为你想要计算的日期，86400 为每一天的秒数， %s 为 1970/01/01 以来的累积总
秒数。 由于 bash 仅支持整数，因此最终需要加上 1 补齐 1970/01/01 当天。
4. 密码不可被更动的天数：(与第 3 字段相比)
第四个字段记录了：这个账号的密码在最近一次被更改后需要经过几天才可以再被变更！如果是 0 的话，
表示密码随时可以更动的意思。这的限制是为了怕密码被某些人一改再改而设计的！如果设定为 20 天的
话，那么当你设定了密码之后， 20 天之内都无法改变这个密码呦！
5. 密码需要重新变更的天数：(与第 3 字段相比)
经常变更密码是个好习惯！为了强制要求用户变更密码，这个字段可以指定在最近一次更改密码后， 在多
少天数内需要再次的变更密码才行。你必须要在这个天数内重新设定你的密码，否则这个账号的密码将会
『变为过期特性』。 而如果像上面的 99999 (计算为 273 年) 的话，那就表示，呵呵，密码的变更没有强
制性之意。
6. 密码需要变更期限前的警告天数：(与第 5 字段相比)
当账号的密码有效期限快要到的时候 (第 5 字段)，系统会依据这个字段的设定，发出『警告』言论给这个
账号，提醒他『再过 n 天你的密码就要过期了，请尽快重新设定你的密码呦！』，如上面的例子，则是密码
到期之前的 7 天之内，系统会警告该用户。
7. 密码过期后的账号宽限时间(密码失效日)：(与第 5 字段相比)
密码有效日期为『更新日期(第 3 字段)』+『重新变更日期(第 5 字段)』，过了该期限后用户依旧没有更新密
码，那该密码就算过期了。 虽然密码过期但是该账号还是可以用来进行其他工作的，包括登入系统取得
bash 。不过如果密码过期了， 那当你登入系统时，系统会强制要求你必须要重新设定密码才能登入继续使
用喔，这就是密码过期特性。
那这个字段的功能是什么呢？是在密码过期几天后，如果使用者还是没有登入更改密码，那么这个账号的
密码将会『失效』， 亦即该账号再也无法使用该密码登入了。要注意密码过期与密码失效并不相同。
8. 账号失效日期：
这个日期跟第三个字段一样，都是使用 1970 年以来的总日数设定。这个字段表示： 这个账号在此字段规
定的日期之后，将无法再使用。 就是所谓的『账号失效』，此时不论你的密码是否有过期，这个『账号』
都不能再被使用！ 这个字段会被使用通常应该是在『收费服务』的系统中，你可以规定一个日期让该账号
不能再使用啦！
9. 保留：
最后一个字段是保留的，看以后有没有新功能加入。

